%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  pgxc_ctl module description
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  This section describes internal structure of \file{pgxc_ctl} module.
  
  For the usage and tutorial of this module, see Part~\ref{part:pgxcCtl} of this report.


%------- Subsec Subsec -----------------------------------------------------

\subsection{Outline of the module}

  Source material of this module will be found in the directory \file{contrib/pgxc_ctl}
  
  This module provide the following feature:
  
  % Pgxc_ctl module feature
  \begin{itemize}
	  \item Configure \XC{} cluster including gtm master/slave, gtm\_proxies, coordinator
	  		master/slave and datanode master/slave.
	  \item Initialize \XC{} cluster based upon the configuration definition.
	  \item Start and stop \XC{} cluster.
	  \item Failover each component if the slave is configured and running.
	  \item Monitor if each component is running.
	  \item Add and remove components.
	  \item Other command interface needed for \XC{} cluster operation.
  \end{itemize}
  
  \file{pgxc_ctl} is essentially a \file{ssh} wrapper to run shell script at remote nodes
  to perform each of the above operations.
  
  The following section describes outline of \file{pgxc_ctl} source code structure, its
  general flow and each component's structure.


%------- Subsec Subsec -----------------------------------------------------

\subsection{\texttt{pgxc\_ctl} source code structure}

  Table~\ref{tab:pgxcCtl:src} (page~\pageref{tab:pgxcCtl:src}) is the list of \file{pgxc_ctl}
  source file.
  
  % pgxc_ctl source file list
  \begin{table}[htp]
	  \begin{center}
		  \caption{\label{tab:pgxcCtl:src}\texttt{pgxc\_ctl} source file list}
		  \begin{tabular}{lp{0.7\hsize}} \hline
				Source File & Description \\ \hline
				\file{bash_handler.c} & {\file{bash} script handler module of \XC{} configuration and
											operation tool.} \\
				\file{bash_handler.h} & {Header file to define \file{bash_handler.c} interface.} \\
				\file{config.c} & {Handles \file{pgxc_ctl} configuration.} \\
				\file{config.h} & {Header file to define \file{config.c} interface.} \\
				\file{coord_cmd.c} & {Coordinator operation module.} \\
				\file{coord_cmd.h} & {\file{coord_cmd.c} interface definition.} \\
				\file{datanode_cmd.c} & {Datanode operation module} \\
				\file{datanode_cmd.h} & {\file{datanode_cmd.c} interface definition.} \\
				\file{do_command.c} & {High level command handler.} \\
				\file{do_command.h} & {\file{do_command.c} interface definition.} \\
				\file{do_shell.c} & {Infrastructure for \file{ssh} command preparation and execution.} \\
				\file{do_shell.h} & {\file{do_shell.c} interface definition.} \\
				\file{gtm_cmd.c} & {GTM operation module.} \\
				\file{gtm_cmd.h} & {\file{gtm_cmd.c} interface definition.} \\
				\file{gtm_util.c} & {Command handler with GTM.} \\
				\file{gtm_util.h} & {\file{gtm_util.c} interface definition.} \\
				\file{make_signature} & {Shell script to build signature file and configuration
											file template embedded in \file{pgxc_ctl_bash.c}.} \\
				\file{mcxt.c} & {Memory handler.} \\
				\file{monitor.c} & {Monitoring \XC{} components.} \\
				\file{monitor.h} & {\file{monitor.c} interface definition.} \\
				\file{pgxc_ctl.bash} & {Original \file{pgxc_ctl} module in \file{bash} script.  This is useful to
										   understand \file{pgxc_ctl} behavior.} \\
				\file{pgxc_ctl_bash.c} & {This file contains default configuration values and
											\file{bash} script to read the configuration file.
											Generated by \file{make_signature}.} \\
				\file{pgxc_ctl.c} & {Main module.} \\
				\file{pgxc_ctl.h} & {Main module interface definition.} \\
				\file{pgxc_ctl_bash.c} & {Module holds configuration template.
											  Generated by \file{make_signature}.} \\
				\file{pgxc_ctl_bash_2} & {Original template to be embedded into \file{pgxc_ctl_bash.c}} \\
				\file{pgxc_ctl_conf_part} & {Original template to be embedded into \file{pgxc_ctl_bash.c}} \\
				\file{pgxc_ctl_log.c} & {Logging module.} \\
				\file{pgxc_ctl_log.h} & {\file{pgxc_ctl_log.c} interface definition.} \\
				\file{signature.h} & {Holds signature information to test if working environment
										matches \file{make_signature} generation.} \\
				\file{utils.c} & {Miscellaneous utility functions.} \\
				\file{utils.h} & {\file{utils.c} interface definition.} \\
				\file{variables.c} & {Variable module.} \\
				\file{variables.h} & {\file{variable.c} interface definition.} \\
				\file{varnames.h} & {Definition of variable symbol and variable name string.} \\
				\hline
		  \end{tabular}
	  \end{center}
  \end{table}


%------- Subsec Subsec -----------------------------------------------------

\subsection{Outline of {\tt pgxc\_ctl} behavior}

  The outline of \file{pgxc_ctl} is as follows:
  
  {
  	  \raggedright
	  \begin{enumerate}
		  \item Handles command line options (\file{main():pgxc_ctl.c}) and environment
				file options (\file{setup_my_env():pgxc_ctl.c}).
		  \item Begins logging (\file{startLog():pgxc_ctl.c}).
		  \item Reads and check configuration.
				\begin{enumerate}
				\item Loads default configuration file (bash script)
					(\file{prepare_pgxc_ctl_bash():pgxc_ctl.c)}.
				\item Loads configuration file (\file{build_configuration_path():pgxc_ctl.c}).
				\item Reads configuration variables (\file{read_configuration():pgxc_ctl.c}).
				\item Checks configuration variables (\file{check_configuration():config.c}).
				\end{enumerate}
		  \item Reads one line of command and handles it. (\file{do_command():do_command.c}).
	  \end{enumerate}
  }


%------- Subsec Subsec -----------------------------------------------------

\subsection{Inside each program files}

  This section describes entries in each program files.
  Header file description may not be given if it contains only function entry declarations.
  
  In each function description, you will find that sometimes execution is
  divided into two steps,
  \textbf{preparation} and \textbf{execution}.
  This allows to run similar \file{ssh} script in parallel at more than one servers.
  
  This saves much time for configuration, start and stop whole \XC{} cluster.
  
  % ==== NOTICE =====
  % Below, we use \FUNC, \FuncRecHdr, \FunRef and \FuncRefTrailor command.   They are
  % defined in additionalCoreModules.tex file.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{bash\_handler.c}}

  This module consists of the following functions.
  
  \FUNC{install_pgxc_ctl_bash()}  %--------------------------------
  
      Builds shell script which contains default configuration parameters
  	  (variable \file{pgxc_ctl_conf_prototype}) and bash functions to extract configuration
  	  variables (variable \file{pgxc_ctl_bash_script}).
      
      This function is called from the following codes:
      
  	  % Function cross reference
      \FuncRefHdr
  		\FuncRef{read_configuration()}{pgxc_ctl.c}{
  			Used to read configuration variables.
  			}\\ \vspace{3pt}
  		\FuncRef{prepare_pgxc_ctl_bash()}{pgxc_ctl.c}{
  			Used to extract \file{bash} script for default configuration and bash functions.
  			}\\ \hline
      \FuncRefTrailor
  
  \FUNC{uninstall_pgxc_ctl_bash()}  %--------------------------------
  
      Removes \file{bash} script installed by \file{instal_pgxc_ctl_bash()}.
      
      This is called from the following code:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{read_configuration()}{pgxc_ctl.c}{
				Used to read configuration variables.
		  		}\\ \hline
      \FuncRefTrailor
  
  
  \FUNC{read_config_file()}  %--------------------------------
  
      Runs configuration file as \file{bash} script and reads configuration variables.
      
      This is for work and is not used by other codes now.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{config.c}}

  This is configuration parser module.
  
  As defined in \file{pgxc_ctl_bash_script[]} variable defined in \file{pgxc_ctl_bash.c}.
     \file{pgxc_ctl} will read one variable value in one line as
  
  \textit{varname} \textit{value} \textit{value} ...
  
  More than one value may be defined if the variable is an array.
  If the variable is defined as a scalar, only the first value will be taken.
  
  \FUNC{get_word()} %-------------------------------------------
  
      This function takes line buffer, scans it, sets a token found and returns the next scanning point.
      This function destroys input line string and returns the token address within the original line buffer.
	  The caller must must copy the found token for
      later use.
      
      This function is used in various place to parse configuration variable output.
      Macro \file{GetToken()} may be defined in several module for the shortcut to 
      this function.
  
  \FUNC{parse_line()} %-------------------------------------------
  
      Parses a line of configuration script output and sets the variable and its value
      to internal variable infrastructure.
      
      This is used only within \file{config.c} module.
  
  \FUNC{parse_line_selet()} %-------------------------------------------
  
      This function checks if the configuration script output line is one of the specified set of variable value
      and set it to internal variable infrastructure.
      Used within \file{config.c} module.
  
  \FUNC{read_vars()} %-------------------------------------------
  
      Reads configuration  script output and sets all the variables and their name
      to internal variable infrastructure.
  
  \FUNC{read_selected_vars()} %-------------------------------------------
  
      Reads configuration script output and sets variables and their values to the
      internal variable infrastructure only those matches specified set of variables.
      
      This is called from the following code:
      
	  % Function cross reference
      \FuncRefHdr
      \FuncRef{setup_my_env()}{pgxc_ctl.c}{
      	Used to setup environmental variables.
      }\\ \hline
      \FuncRefTrailor
  
  \FUNC{install_conf_prototype()} %-------------------------------------------
  
      This function builds the configuration file prototype.
      
      This is for the future usage and is not used at present.
  
  \FUNC{addServer()} %-------------------------------------------
  
      This function checks if the given server has already been in
      the server list and add it if it is new to the list.
      
      This is called from the following code:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{makeServerList}{config.c}{
				Used to build list of servers of the cluster.
			  	}\\ \hline
      \FuncRefTrailor
  
  \FUNC{makeSererList()} %-------------------------------------------
  
      This function builds \XC{} server list in internal variable infrastructure.
      
      This is called from the following codes:
      
	  % Function cross reference
      % For coordinator and datanode, these check is done
      % using resource specific conflict test.
      \FuncRefHdr
		  \FuncRef{check_configuration()}{config.c}{
				Used in initial configuration check and build server list.
				}\\ \vspace{3pt}
		  \FuncRef{add_gtmSlave()}{gtm_cmd.c}{
				Used in adding gtm slave.
				}\\ \vspace{3pt}
		  \FuncRef{add_gtmProxy()}{gtm_cmd.c}{
				Used in adding gtm proxy.
				}\\ \vspace{3pt}
		  \FuncRef{remove_gtmProxy()}{gtm_cmd.c}{
				Used in removing gtm proxy.
				}\\ \hline
      \FuncRefTrailor
  
  \FUNC{is_none()} %-------------------------------------------
  
      This function is used to check if a given name (node name, server name, etc.) is \file{NULL}.
      So far, ``\file{none}'' and ``\file{N/A}'' are interrupted as \file{NULL}.
      
      This is very common function and called from various functions.
      The usage is quite obvious and no caller information is given here.
  
  \FUNC{emptyGtmSlave()} %-------------------------------------------
  
      Initializes gtm slave information to \file{NULL}.
      
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{handle_no_slaves()}{config.c}{
				Used in initial configuration check to handle \file{NULL} values.
				}\\ \hline
      \FuncRefTrailor
  
  \FUNC{checkConfiguredAndSize()} %-------------------------------------------
  
      Checks if all the specified variable has same number of array member.
      
      Used inside \file{config.c} module.
  
  \FUNC{checkSPecificResourceConflict()} %-------------------------------------------
  
      Checks resource conflict in the configuration.
      Component name, port and work directory are checked.
      
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{add_gtmSlave()}{gtm_cmd.c}{
				Used in adding gtm slave.
			  	}\\ \vspace{3pt}
		  \FuncRef{add_gtmProxy()}{gtm_cmd.c}{
				Used in adding a gtm proxy.
			  	}\\ \hline
      \FuncRefTrailor
  
  \FUNC{checkNameConflict()} %-------------------------------------------
  
      Tests if a given name does not conflict with others.
      
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{add_coordinatorMaster()}{coord_cmd.c}{
				Used in adding a coordinator master.
			  	}\\ \vspace{3pt}
		  \FuncRef{checkSPecificResourceConflict()}{config.c}{
				Used in checking all the resource conflict.
			  	}\\ \vspace{3pt}
		  \FuncRef{add_datanodeMaster()}{datanode_cmd.c}{
				Used in adding a datanode master.
			  	}\\ \hline
      \FuncRefTrailor
  
  \FUNC{checkPortConflict()} %-------------------------------------------
  
      Tests if a given port at the given host conflicts with other ports in the host.
      
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{add_coordinatorMaster()}{coord_cmd.c}{
				Used in adding a coordinator master.
				}\\ \vspace{3pt}
		  \FuncRef{add_coordinatorSlave()}{coord_cmd.c}{
				Used in adding a coordinator slave.
				}\\ \vspace{3pt}
		  \FuncRef{checkSPecificResourceConflict()}{config.c}{
				Used in checking all the resource conflict.
				}\\ \vspace{3pt}
		  \FuncRef{add_datanodeMaster()}{datanode_cmd.c}{
				Used in adding a datanode master.
				}\\ \vspace{3pt}
		  \FuncRef{add_datanodeSlave()}{datanode_cmd.c}{
				Used in adding a datanode slave.
				}\\ \hline
      \FuncRefTrailor
  
  \FUNC{checkDirConflict()} %-------------------------------------------
  
      Tests if a given directory at the given host conflicts with other directories in the host.
      
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{add_coordinatorMaster()}{coord_cmd.c}{
			Used in adding a coordinator master.
		  	}\\ \vspace{3pt}
		  \FuncRef{add_coordinatorSlave()}{coord_cmd.c}{
			Used in adding a coordinator slave.
		  	}\\ \vspace{3pt}
		  \FuncRef{checkSPecificResourceConflict()}{config.c}{
			Used in checking all the resource conflict.
		  	}\\ \vspace{3pt}
		  \FuncRef{add_datanodeMaster()}{datanode_cmd.c}{
			Used in adding a datanode master.
		  	}\\ \vspace{3pt}
		  \FuncRef{add_datanodeSlave()}{datanode_cmd.c}{
			Used in adding a datanode slave.
		  	}\\ \hline
      \FuncRefTrailor
  
  \FUNC{checkResourceConflict()} %-------------------------------------------
  
      Tests if there's any conflict among source and destination checks duplicate in names, ports and rectories.
      
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{verifyResource()}{config.c}{
			Used in verifying resource conflict at running.
		  	}\\ \hline
      \FuncRefTrailor
  
  \FUNC{verifyResource()} %-------------------------------------------
  
      This checks whole \XC{} resource is configured to run as a cluster.
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{check_configuration()}{config.c}{
			Used in checking if minimum components are configured as \XC{} cluster.
		  	}\\ \hline
      \FuncRefTrailor
  
  \FUNC{check_configuration()} %-------------------------------------------
  
      Checks if minimum components are configured as \XC{} cluster.
      
      Called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{main()}{pgxc_ctl.c}{
			Used in initial configuration read.
		  	}\\ \hline
      \FuncRefTrailor
  
  \FUNC{backup_configuration()} %-------------------------------------------
  
      This function backs up configuration file to a remote site as specified.
      \file{pgxc_ctl} adds updated configuration line at the last of the configuration file when
      the cluster changes by failover, adding and removing nodes.
      This feature helps to maintain \file{pgxc_ctl} configuration file safely.
      
      It is called by the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{add_coordinatorMaster()}{coord_cmd.c}{
			Used in adding a coordinator master.
		  }\\ \vspace{3pt}
		  \FuncRef{add_coordinatorSlave()}{coord_cmd.c}{
			Used in adding a coordinator slave.
		  }\\ \vspace{3pt}
		  \FuncRef{remove_coordinatorMaster()}{coord_cmd.c}{
			Used in removing a coordinator master.
		  }\\ \vspace{3pt}
		  \FuncRef{remove_coordinatorSlave()}{coord_cmd.c}{
			Used in removing a coordinator slave.
		  }\\ \vspace{3pt}
		  \FuncRef{add_datanodeMaster()}{datanode_cmd.c}{
			Used in adding a datanode master.
		  }\\ \vspace{3pt}
		  \FuncRef{add_datanodeSlave()}{datanode_cmd.c}{
			Used in adding a datanode slave.
		  }\\ \vspace{3pt}
		  \FuncRef{remove_datanodeMaster()}{datanode_cmd.c}{
			Used in adding a datanode master.
		  }\\ \vspace{3pt}
		  \FuncRef{remove_datanodeSlave()}{datanode_cmd.c}{
			Used in adding a datanode slave.
		  }\\ \vspace{3pt}
		  \FuncRef{add_gtmSlave()}{gtm_cmd.c}{
			Used in adding gtm slave.
		  }\\ \vspace{3pt}
		  \FuncRef{remove_gtmSlave()}{gtm_cmd.c}{
			Used in adding gtm slave.
		  }\\ \vspace{3pt}
		  \FuncRef{failover_gtm()}{gtm_cmd.c}{
			Used in gtm failover.
		  }\\ \vspace{3pt}
		  \FuncRef{remove_gtmProxy()}{gtm_cmd.c}{
			Used in removing a gtm proxy.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{getNodeType()} %-------------------------------------------
  
      Returns node type (gtm, gtm\_proxy, coordinator, datanode, or server name).
      
      It is called by the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{monitor_something()}{monitor.c}{
			Used in getting the type of the given name to determine how to monitor the target.
		  }\\ \vspace{3pt}
		  \FuncRef{kill_something()}{do_command.c}{
			Used in determining what is going to be killed.
		  }\\ \vspace{3pt}
		  \FuncRef{show_config_something()}{do_command.c()}{
			Used in determining what configuration to show about.
		  }\\ \vspace{3pt}
		  \FuncRef{do_clean_command()}{do_command.c}{
			Used in determining what kind of resource going to cleanup.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{getDefaultWalSender()} %-------------------------------------------
  
      Determine maximum number of WAL sender process.
      
      It is called by the following codes:
      
      \FuncRefHdr
		  \FuncRef{add_coordinatorSlave()}{coord_cmd.c}{
			Used in adding coordinator slave.
		  }\\ \vspace{3pt}
		  \FuncRef{add_datanodeSlave()}{datanode_cmd.c}{
			Used in adding datanode slave.
		  }\\ \hline
      \FuncRefTrailor


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{coord\_cmd.c}}

  This module performs operation on coordinators and consists of the following functions.
  
  \FUNC{init_coordinator_master_all()} %-----------------------------
  
      This is a wrapper function for \file{init_coordinator_master()} to initialize all the coordinator master
      defined in the configuration file.
      
      It is called by the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{init_all()}{do_command.c}{
			Used in initializing everything defined in the configuration file.
		  }\\ \vspace{3pt}
		  \FuncRef{do_init_command()}{do_command.c}{
			Used in handling \texttt{init coordinator all} command and
			\texttt{init coordinator master all} command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_initCoordinatorMaster()} %-----------------------------
  
      This function prepares internal \file{cmd_t} structure to describe the step for the initialization
      of one coordinator master.
      
      The step includes the following:
      
	  % prepare_initCoordinatorMaster() steps.
      \begin{enumerate}
		  \item Checks if the target coordinator master is not running.
		  \item Cleans up the work directory.
		  \item Run \file{initdb}.
		  \item Determines which gtm\_proxy to use, or to use gtm directly.
		  \item Constructs \file{postgresql.conf}.
		  \item Constructs WAL shipping replication if the slave is configured.
		  \item Constructs \file{pg_hba.conf} file.
      \end{enumerate}.
      
      It is called from \file{init_coordinator_master} in \file{coord_cmd.c}
      to initialize one or more than one coordinator masters.
  
  \FUNC{init_coordinator_master()} %-----------------------------
  
      This function initializes specified coordinator masters, which can be one or more than one.
      
      The step is as follows:
      
	  % steps
      \begin{enumerate}
		  \item Prepares initialization steps for all the coordinator masters specified using
				\file{prepare_initCoordinatorMaster()}.
		  \item Performs the steps using \file{doCmdList()} function defined in \file{do_shell.c}
      \end{enumerate}
  
  \FUNC{init_coordinator_slave_all()} %-----------------------------
  
      This function initializes all the coordinator slaves defined in the configuration file.
      
      It is a wrapper of \file{init_coordinator_slave()} function described below.
      
      It is called from the following codes;
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{init_all()}{do_command.c}{
			Used in initializing everything defined in the configuration file.
		  }\\ \vspace{3pt}
		  \FuncRef{do_init_command()}{do_command.c}{
			Used in handling \texttt{init coordinator all} command and
			\texttt{init coordinator slave all} command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_initCoordinatorSlave()} %-----------------------------
  
      This function prepares internal \file{cmd_t} structure to describe the step for the initialization
      of one coordinator slave.
      
      The step includes the following:
      
	  % steps
      \begin{enumerate}
		  \item Checks if corresponding coordinator master is configured.
		  \item Cleans up and reinitialize the work directory.
		  \item Checks if the coordinator master is running.
		  		It is necessary to build the base backup of the master using \file{pg_basebackup} utility.
		  \item Builds the base backup.
		  		The source code has additional codes to build the base backup with primitive way.
		  \item Builds \file{recovery.conf} file at the slave.
		  \item Configures \file{postgresql.conf} file at the slave.
      \end{enumerate}.
      
      It is called from \file{init_coordinator_slave()} in \file{coord_cmd.c}
      to initialize one or more than one coordinator slaves.
  
  \FUNC{init_coordinator_slave()} %-----------------------------
  
      This function initializes specified coordinator slaves, which can be one or more than one.
      
      The step is as follows:
      
      \begin{enumerate}
		  \item Checks if coordinator slave is configured.
		  \item Prepares initialization steps for all the coordinator slaves specified
		  		using \file{prepare_initCoordinatorSlave()}.
		  \item Performs the steps using \file{doCmdList()} function defined in \file{do_shell.c}
      \end{enumerate}
  
  \FUNC{configure_nodes_all()} %-----------------------------
  
      This is a wrapper function for \file{configure_nodes()} and is called form \file{init_all()}
      function to perform \texttt{init all} command.
  
  \FUNC{configure_nodes_all()} %-----------------------------
  
      This function issues \texttt{CREATE NODE} and \texttt{ALTER NODE} statement at all the coordinators
      to configure \XC{} cluster at each coordinator.
      
      This function is a wrapper of \file{configure_nodes()} and is called from
	  \file{init_all()} function at \file{do_command.c} module to perform
	  \texttt{init all} command.
  
  \FUNC{configure_nodes()} %-----------------------------
  
      This function runs \texttt{CREATE NODE} and \texttt{ALTER NODE} statement at give coordinators
      to configure \XC{} cluster at each coordinator.
      
      This function uses \file{prepare_configureNode()} to set up needed steps for each coordinator.
      It is called from \file{do_configure_command()} at \file{do_command.c} module.
  
  \FUNC{prepare_configureNode()} %-----------------------------
  
      This function prepares necessary step to configure one coordinator with
	  \texttt{CREATE NODE} and \texttt{ALTER NODE} statement.
      It is called from \file{configure_nodes()} at \file{coord_cmd.c}.
      
      \texttt{ALTER NODE} statement is used to update own coordinator information.
  
  \FUNC{kill_coordinator_master_all()} %-----------------------------
  
      This is a wrapper for \file{kill_coordinator_master()}.
      It is for the future usage and is not used now.
      \file{kill_coordinator_master()} is used instead.
  
  \FUNC{prepare_killCoordinatorMaster()} %-----------------------------
  
      Build necessary step to kill one coordinator master.
      It is called by \file{kill_coordinator_master()} described below.
  
  \FUNC{kill_coordinator_master()} %-----------------------------
  
      This function kills specified coordinator masters, which can be one or more than one,
	  using \file{prepare_killCoordinatorMaster()} in \file{coord_cmd.c}.
  
  \FUNC{kill_coordinator_slave_all()} %-----------------------------
  
      This is a wrapper for \file{kill_coordinator_slave()}.
      It is for the future usage and is not used now.
      \file{kill_coordinator_slave()} is used instead.
  
  \FUNC{prepare_killCoordinatorSlave()} %-----------------------------
  
      Build necessary step to kill one coordinator slave.
      It is called by \file{kill_coordinator_slave()} described below.
  
  \FUNC{kill_coordinator_slave()} %-----------------------------
  
      This function kills specified coordinator slaves, which can be one or more than one,
	  using \file{prepare_killCoordinatorSlave()} in \file{coord_cmd.c}.
  
  \FUNC{prepare_cleanCoordinatorMaster()} %-----------------------------
  
      This function prepares necessary step to cleanup the working directory of a given coordinator master.
      
      It is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{clean_coordinator_master()}{coord_cmd.c}{
			Used to clean the work directory of one or more than one coordinator masters.
		  }\\ \vspace{3pt}
		  \FuncRef{do_clean_command()}{docommand.c}{
			Used in performing \texttt{clean} command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{clean_coordinator_master()} %-----------------------------
  
      This function cleans up working directory of one or more than one coordinator master specified.
      Necessary steps are build using \file{prepare_cleanCoordinatorMaster()} in \file{coord_cmd.c}.
      
      It is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{clean_coordinator_master_all()}{coord_cmd.c}{
			Used to clean the work directory of all the coordinator masters.
		  }\\ \vspace{3pt}
		  \FuncRef{do_clean_command()}{docommand.c}{
			Used in performing \texttt{clean} command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{clean_coordinator_master_all()} %-----------------------------
  
      This is a wrapper for \file{clean_coordinator_master()} and is called from
	  \file{do_clean()} in \file{do_command.c} to cleanup all the coordinator master's
	  work directories.
  
  \FUNC{prepare_cleanCoordinatorSlave()} %-----------------------------
  
      This function prepares necessary step to cleanup the working directory of a given
	  coordinator slave.
      
      It is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{clean_coordinator_slave()}{coord_cmd.c}{
			Used to clean the work directory of one or more than one coordinator masters.
		  }\\ \vspace{3pt}
		  \FuncRef{do_clean_command()}{docommand.c}{
			Used in performing \texttt{clean} command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{clean_coordinator_slave()} %-----------------------------
  
      This function cleans up working directory of one or more than one coordinator
	  master specified.
      Necessary steps are build using \file{prepare_cleanCoordinatorSlave()} in \file{coord_cmd.c}.
      
      It is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{clean_coordinator_slave_all()}{coord_cmd.c}{
			Used to clean the work directory of all the coordinator masters.
		  }\\ \vspace{3pt}
		  \FuncRef{do_clean_command()}{docommand.c}{
			Used in performing \texttt{clean} command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{clean_coordinator_slave_all()} %-----------------------------
  
      This is a wrapper for \file{clean_coordinator_slave()} and is called from
	  \file{do_clean()} in \file{do_command.c} to cleanup all the coordinator slave's
	  work directories.
  
  \FUNC{add_coordinatorMaster()} %-----------------------------
  
      This function adds coordinator master to \XC{} cluster.
      
      Because coordinator master would be added one after another, handling to add more than
	  one coordinator masters may not make a good sense.
      It is done in series with separate \file{pgxc_ctl} command.
      
      For steps done, see section~\ref{pgxcCtl:addCoordMaster} in part~\ref{part:pgxcCtl} on
	  page~\pageref{pgxcCtl:addCoordMaster}.
  
  \FUNC{add_coordinatorSlave()} %-----------------------------
  
      This function adds a coordinator slave to specified coordinator master.
      
      Because a coordinator slave would be added one after another, adding more than
	  one coordinator slaves may not make a good sense.
      It is done in series with separate \file{pgxc_ctl} command.
      
      For steps done, see section~\ref{pgxcCtl:addCoordSlave} in part~\ref{part:pgxcCtl} on
	  page~\pageref{pgxcCtl:addCoordSlave}.
  
  \FUNC{remove_coordinatorMaster()} %-----------------------------
  
      This function removes one coordinator master from \XC{} cluster.
      
      For steps done, see section~\ref{pgxcCtl:removeCoordMaster} in part~\ref{part:pgxcCtl} on
	  page~\pageref{pgxcCtl:removeCoordMaster}.
  
  \FUNC{remove_coordinatorSlave()} %-----------------------------
  
      This function removes one coordinator slave from \XC{} cluster.
      
      For steps done, see section~\ref{pgxcCtl:removeCoordSlave} in part~\ref{part:pgxcCtl} on
	  page~\pageref{pgxcCtl:removeCoordSlave}.
  
  \FUNC{start_coordinator_master_all()} %-----------------------------
  
      This function is a wrapper to the function \file{start_coordinator_master()} in
	  \file{coord_cmd.c} to start all the coordinator master.
      
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{init_all()}{do_command.c}{
			Used in starting everything after the whole cluster initialization.
		  }\\ \vspace{3pt}
		  \FuncRef{start_all()}{do_command.c}{
			Used in starting everything.
		  }\\ \vspace{3pt}
		  \FuncRef{do_start_command()}{do_command.c}{
			Used in handling \texttt{start coordinator all} command and \texttt{start coordinator master
			all} command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_startCoordinatorMaster()} %-----------------------------
  
      Prepares necessary steps to start one coordinator master.
      
      This is called from \file{start_coordinator_master()} in \file{coord_cmd.c} to start one or more than
	  one coordinator master.
  
  \FUNC{start_coordinator_master()} %-----------------------------
  
      Starts one ore more than one coordinator master in parallel.
      
      This is called from the following codes;
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{add_coordinatorMaster()}{coord_cmd.c}{
			Used in starting added coordinator master.
		  }\\ \vspace{3pt}
		  \FuncRef{start_coordinator_master_all()}{coord_cmd.c}{
			Used in starting every coordinator master.
		  }\\ \vspace{3pt}
		  \FuncRef{do_start_command()}{do_command.c}{
			Used in handling \texttt{start coordinator master all} command and
			\texttt{start coordinator} command.
		  }\\ \hline
      \FuncRefTrailor
  
  
  \FUNC{start_coordinator_slave_all()} %-----------------------------
  
      This function is a wrapper to the function \file{start_coordinator_slave()} in
	  \file{coord_cmd.c} to start all the coordinator master.
      
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{init_all()}{do_command.c}{
			Used in starting everything after the whole cluster initialization.
		  }\\ \vspace{3pt}
		  \FuncRef{start_all()}{do_command.c}{
			Used in starting everything.
		  }\\ \vspace{3pt}
		  \FuncRef{do_start_command()}{do_command.c}{
			Used in handling \texttt{start coordinator all} command and \texttt{start coordinator slave all}
			command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_startCoordinatorSlave()} %-----------------------------
  
      Prepares necessary steps to start one coordinator master.
      %
      This is called from \file{start_coordinator_slave()} in \file{coord_cmd.c} to start one or more
	  than one coordinator master.
  
  \FUNC{start_coordinator_slave()} %-----------------------------
  
      Starts one or more than one coordinator slaves in parallel.
      %
      This is called from the following codes;
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{add_coordinatorSlave()}{coord_cmd.c}{
			Used in starting added coordinator slave.
		  }\\ \vspace{3pt}
		  \FuncRef{start_coordinator_slave_all()}{coord_cmd.c}{
			Used in starting every coordinator slave.
		  }\\ \vspace{3pt}
		  \FuncRef{do_start_command()}{do_command.c}{
			Used in handling \texttt{start coordinator slave all} command and \texttt{start coordinator}
			command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{stop_coordinator_master_all()} %-----------------------------
  
      This function is a wrapper to the function \file{stop_coordinator_master()} in
	  \file{coord_cmd.c} to stop all the coordinator master.
      %
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{stop_all()}{do_command.c}{
			Used in stopping everything.
		  }\\ \vspace{3pt}
		  \FuncRef{do_stop_command()}{do_command.c}{
			Used in handling \texttt{stop coordinator all} command and \texttt{stop coordinator master all}
			command.
		  }\\ \hline
      \FuncRefTrailor
  
  
  \FUNC{prepare_stopCoordinatorMaster()} %-----------------------------
  
      Prepares necessary steps to stop one coordinator master.
      %
      This is called from \file{stop_coordinator_master()} in \file{coord_cmd.c} to stop one or
	  more than one coordinator master.
  
  \FUNC{stop_coordinator_master()} %-----------------------------
  
      Stops one ore more than one coordinator masters in parallel.
      %
      This is called from the following codes;
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{stop_coordinator_master_all()}{coord_cmd.c}{
			Used to stop every coordinator master.
		  }\\ \vspace{3pt}
		  \FuncRef{do_stop_command()}{do_command.c}{
			Used in handling \texttt{stop coordinator master all} command and \texttt{stop coordinator}
			command.
		  }\\ \hline
      \FuncRefTrailor
      
  
  \FUNC{stop_coordinator_slave_all()} %-----------------------------
  
      This function is a wrapper to the function \file{stop_coordinator_slave()} in
	  \file{coord_cmd.c} to stop all the coordinator slaves.
      %
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{stop_all()}{do_command.c}{
			Used in stopping everything.
		  }\\ \vspace{3pt}
		  \FuncRef{do_stop_command()}{do_command.c}{
			Used in handling \texttt{stop coordinator all} command and \texttt{stop coordinator slave all}
			command.
		  }\\ \hline
      \FuncRefTrailor
  
  
  \FUNC{prepare_stopCoordinatorSlave()} %-----------------------------
  
      Prepares necessary steps to stop one coordinator slave.
      %
      This is called from \file{stop_coordinator_slave()} in \file{coord_cmd.c} to stop one or more than
	  one coordinator slave.
  
  \FUNC{stop_coordinator_slave()} %-----------------------------
  
      Stops one ore more than one coordinator slaves in parallel.
      %
      This is called from the following codes;
      
      \FuncRefHdr
		  \FuncRef{stop_coordinator_slave_all()}{coord_cmd.c}{
			Used to stop all the coordinator slaves.
		  }\\ \vspace{3pt}
		  \FuncRef{do_stop_command()}{do_command.c}{
			Used in handling ``\texttt{stop coordinator slave all}'' command and
			``\texttt{stop coordinator}''
			command.
		  }\\ \hline
      \FuncRefTrailor
  
  
  \FUNC{failover_coordinator()} %-----------------------------
  
      This function promotes specified coordinator slave to master.
      This can handle more than one coordinator failover but is done in series, not in parallel.
      
      \file{failover_oneCoordinator()} takes care of each coordinator failover as described next.
      
      This is called from \file{do_failover_command()} in \file{do_command.c} to handle
	  \texttt{failover coordinator} command.
  
  \FUNC{failover_oneCoordinator()} %-----------------------------
  
      Performs one coordinator slave promotion to master.
      %
      This is called from \file{failover_coordinator()} in \file{do_command.c}.
      
      The steps done in this function is described in section~\ref{pgxcCtl:promoteCoordSlave} of
	  part~\ref{part:pgxcCtl} on page~\pageref{pgxcCtl:promoteCoordSlave}.
  
  \FUNC{show_config_coordMasterSlaveMulti()} %-----------------------------
  
      Shows coordinator master and slave configuration for given names.
      
      This is called from \file{show_configuration} in \file{do_command.c} to handle
      \texttt{show configuration} command.
  
  \FUNC{show_config_coordMasterMulti()} %-----------------------------
  
      Shows configuration of one or more than one coordinator master.
      %
      This is called by the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{show_config_coordMasterSlaveMulti()}{coord_cmd.c}{
			Used to stop every coordinator slave.
		  }\\ \vspace{3pt}
		  \FuncRef{show_configuration()}{do_command.c}{
			Used in handling \texttt{show configuration} command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{show_config_coordMaster()} %-----------------------------
  
      Shows configuration of given coordinator master.
      %
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{show_config_coordMasterSlaveMulti()}{coord_cmd.c}{
		  
		  }\vspace{-10pt} \\
		  \FuncRef{show_config_coordMasterMulti()}{coord_cmd.c}{
		  
		  }\vspace{-10pt} \\
		  \FuncRef{show_config_something()}{do_command.c}{
		  
		  }\vspace{-10pt} \\
		  \FuncRef{show_config_host()}{do_command.c}{
		  
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{show_config_coordSlave()} %-----------------------------
  
      Shows configuration of given coordinator slave.
      %
      This is called from the following codes:
      
	  % Function cross reference
      \FuncRefHdr
		  \FuncRef{show_config_coordMasterSlaveMulti()}{coord_cmd.c}{
		  
		  }\vspace{-10pt} \\
		  \FuncRef{show_config_coordSlaveMulti()}{coord_cmd.c}{
		  
		  }\vspace{-10pt} \\
		  \FuncRef{show_config_something()}{do_command.c}{
		  
		  }\vspace{-10pt} \\
		  \FuncRef{show_config_host()}{do_command.c}{
		  
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  
  \FUNC{check_AllCoordRunning()} %-----------------------------
  
      Checks if all the coordinator masters are running.
      %
      This is called from \file{add_coordinatorMaster()} in \file{coord_cmd.c} to check if
	  coordinator master can be added to \XC{} cluster.



% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{datanode\_cmd.c}}

  \file{datanode_cmd.c} structure is very similar to \file{coord_cmd.c}.
  There will be no difficulty to understand the implementation with the last section's description.
  

% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{do\_command.c}}
  
  \file{do_command.c} performs most of \file{pgxc_ctl} command.
  
  \FUNC{do_echo_command()}
  
      Performs \texttt{echo} command.
      This is called from \file{do_singleLine()} in \file{do_command.c}.
  
  \FUNC{do_prepareConfFile()}
  
      Builds template of \file{pgxc_ctl} configuration file.
      This is called from \file{do_singleLine()} in \file{do_command.c} to perform \file{prepare} command.
  
  \FUNC{do_deploy()}
  
      Performs \texttt{deploy} command.
      %
      This is called from \file{do_singleLine()} in \file{do_comamnd.c} to perform \texttt{deploy} command.
  
  \FUNC{deploy_xc()}
  
      Performs \texttt{deploy} command.
      %
      This is called from \file{do_deploy()} in \file{do_command.c}.
  
  \FUNC{do_set()}
  
      Sets (set of) value to specified variable.
      This functions sets up any variable even if it is not pre-defined in the configuration file.
      %`
      This is called from \file{do_singleline()} in \file{do_command.c} to perform \texttt{set} command.
  
  \FUNC{do_failover_command()}
  
      Performs \file{failover} command and called from \file{do_singleline()} in \file{do_command.c}
  
  \FUNC{do_reconnect_command()}
  
      Performs \texttt{reconnect} command and called from \file{do_singleline()} in \file{do_command.c}.
  
  \FUNC{do_kill_command()}
  
      Performs \texttt{kill} command and called from \file{do_singleline()} in \file{do_command.c}.
  
  \FUNC{init_all()}
  
      Performs \texttt{init all} command and called from \file{do_init()} command in \file{do_command.c}.
  
  \FUNC{do_init_command()}
  
      Performs \texttt{init} command and called from \file{do_singleline()} in \file{do_command.c}.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{do\_shell.c}}

  This module is a basic infrastructure to run various shell script.
  
  Many functions in this module use two structures called \file{cmd_t} and \file{cmdList_t} as interfaces
  to the caller.
  
  \file{cmd_t} defines series of shell script which can run either locally or at remote servers.
  Shell commands defined in this structure are executed in series.
  
  \file{cmdList_t} consists of one or more than one \file{cmd_t} structures, which are executed in parallel.
  
  Definition of these structures are given in \file{do_shell.h}.
  
  Functions in this module are as follows:
  
  \FUNC{do_shell_SigHandler()}
  
      Signal handler during command execution.
  
  \FUNC{createLocalFileName()}
  
      Creates path to stdin, stdout, or stderr file for each piece of local shell command.
      %
      This is called from the following codes;
      
      \FuncRefHdr
		  \FuncRef{doImmediate()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{prepareStdout()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{show_Resource()}{do_command.c}{
		  }\vspace{-10pt} \\
		  \FuncRef{do_stop_command()}{do_command.c}{
			Used in performing ``\texttt{show resource}'' command.
		  }\\ \hline
      \FuncRefTrailor
  
  \FUNC{createRemoteFileName()}
  
      Creates path to stdin, stdout, or stderr file for each piece of remote shell command.
      %
      This is called from the following codes;
      
      \FuncRefHdr
		  \FuncRef{doImmediate()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{prepareStdout()}{do_shell.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{doImmediateRaw()}
  
      This function runs any command foreground locally.
      %
      Argument to this function is same as \texttt{printf()} so that caller do not have to prepare
      command string using \texttt{spirntf()}.
      
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{add_coordinatorMaster()}{coord_cmd.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{doImmediate()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{touchStdout()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{doCmdEl()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{doCmdList()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{do_cleanCmdEl()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{doConfigBackup()}{do_shell.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{show_Resource()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{do_singleLine()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{add_datanodeMaster()}{datanode_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{pgxc_popen_wRaw()}
  
      Begins local shell command using \file{popen()} so that the caller can write data to
	  the shell as \file{stdin}.
      
      Argument to this function is same as \file{printf()} so that caller do not have to prepare
      command string using \file{spirntf()}.
      
      This is a utility function called from various codes.
  
  \FUNC{pgxc_popen_w()}
  
      Begins remote shell command using \file{popen()} so that the caller can write data to
	  the shell as \file{stdin}.
      
      Argument to this function is same as \file{printf()} with remote host name so that
	  caller do not have to prepare command string using \file{spirntf()}.
      
      This is a utility function called from various codes.
  
  \FUNC{doImmediate()}
  
      This function executes one remote shell command at foreground.
      
      Argument to this function is same as \file{printf()} with additional host name and
	  \file{stdin} file name.
      Caller must prepare the contents of \file{stdin} file before calling.
      
      This is a utility function called from various codes.
  
  \FUNC{initCmdList()}
  
      Allocates and initializes \file{cmdList_t} structure.
      
      This is a utility function called from various codes.
  
  \FUNC{initCmd()}
  
      Allocates and initializes \file{cmd_t} structure.
      
      This is a utility function called from various codes.
  
  \FUNC{clearStdin()}
  
      Removes \file{stdin} file defined in \file{cmd_t} structure and cleans its entry in \file{cmd_t} structure.
      
      This is a utility function called from various codes.
  
  \FUNC{doCmd()}
  
      Executes shell commands defined in \file{cmd_t} structure one after another.
      
      This is a utility function called from various codes.
  
  \FUNC{allocActualCmd()}
  
      Allocates a buffer to store actual shell command to run into \file{cmd_t} structure.
      This is used to launch actual shell command with redirection of \file{stdin},
	  \file{stdout} and \file{stderr} as needed.
      
      This is a utility function called from various codes.
  
  \FUNC{doCmdEl()}
  
      Executes one remote or local shell command defined in \file{cmd_t} structure.
      This function resolves \file{stdin}, \file{stdout} and \file{stderr} redirection as needed.
      
      This is a utility function called from various codes.
  
  \FUNC{doCmdList()}
  
      Executes shell commands defined in \file{cmdList_t} structure in parallel.
      
      This is a utility function called from various codes.
  
  \FUNC{appendCmdEl()}
  
      Appends given \file{cmd_t} structure at the end of specified \file{cmd_t} structure.
      
      This is a utility function called from various codes.
  
  \FUNC{do_cleanCmdEl()}
  
      Releases given \file{cmd_t} structure.
      Please note that this function does not take care of internal \file{cmd_t} structure chain.
      This is handled by \file{do_cleanCmd()} function described below.
      Before freeing all the memory allocated, this removes \file{stdin} and \file{stdout} file
	  defined in this structure.
      
      This is a utility function called from various codes.
  
  \FUNC{do_cleanCmd()}
  
      Releases all the shell command chain in the given \file{cmd_t} structure.
      Each command chain element is released by \file{do_cleanCmdEl()}.
      
      This is a utility function called from various codes.
  
  \FUNC{do_cleanCmdList()}
  
      Releases all the shell command defined in the given \file{cmdList_t} structure.
      Each \file{cmd_t} structure defined in it is released by \file{do_cleanCmd()} function
	  described above.
      
      This is a utility function called from various codes.
  
  \FUNC{addCmd()}
  
      Adds \file{cmd_t} structure to \file{cmdList_t} structure.
  
  \FUNC{cleanLastCmd()}
  
      Releases the mast \file{cmd_t} structure in the given \file{cmd_t} shell command chain.
      
      This is a utility function and is called from various codes.
  
  \FUNC{nextSize()}
  
      Calculates new buffer size when it is enlarged.
      
      This is a utility function and is called from various codes.
  
  \FUNC{getCleanHostname()}
  
      Gets host name without domain qualification.
      
      This is a utility function and is called from various codes.
  
  \FUNC{prepareStdout()}
  
      Scans each shell command defined in \file{cmdList_t} structure.
      If \file{stdout} is not set, set it.
      
      This is a utility function and is called from various codes.
  
  \FUNC{makeConfigBackupCmd()}
  
      Builds \file{cmd_t} structure to perform configuration file backup.
      
      This is for future use and is not used yet.
  
  \FUNC{doConfigBackup()}
  
      Backs up configuration file.
      
      This is called from \file{failover_oneDatanode()} in \file{datanode_cmd.c}  to promote one datanode.
  
  \FUNC{dump_cmdList()}
  
      Prints content of given \file{cmdList_t} structure.
      This is for debug and is called from \file{doCmdList()} in \file{do_shell.c}.
  

% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{gtm\_cmd.c}}
  
  This module performs configuration, initialization and operation of gtm and gtm\_proxy.
  
  Functions defined in this module are as follows:
  
  \FUNC{prepare_initGtmMaster()}
  
      Builds \file{cmd_t} structure to initialize gtm master.
      %
      This is called from \file{init_gtm_master()} in \file{gtm_cmd.c} to initialize gtm master.
  
  \FUNC{init_gtm_master()}
  
      Initializes gtm master.
      %
      This is called from \file{init_all()} and \file{do_init_command()} in \file{do_command.c}.
  
  \FUNC{add_gtmSlave()}
  
      Adds gtm slave.
      This is called from \file{do_add_command()} in \file{do_command.c}.
  
  \FUNC{remove_gtmSlave()}
  
      Removes gtm slave.
      This is called from \file{do_remove_command()} in \file{do_command.c}.
  
  \FUNC{prepare_initGtmSlave()}
  
      Builds \file{cmd_t} structure to initialize gtm slave.
      This is called from \file{init_gtm_slave()} in \file{gtm_cmd.c}.
  
  \FUNC{init_gtm_slave()}
  
      Initializes gtm slave.
      %
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{init_all()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{do_init()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{add_gtmSlave()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_startGtmMaster()}
  
      Builds \file{cmd_t} structure to start gtm master.
      %
      This is called from \file{start_gtm_master()} in \file{gtm_cmd.c}.
  
  
  \FUNC{start_gtm_master()}
  
      Starts gtm master.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{init_all()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{start_all()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{add_gtmSlave()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{init_all()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{start_all()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{do_start()}{do_command.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_startGtmSlave()}
  
      Builds \file{cmd_t} structure to start gtm slave.
      This is called from \file{start_gtm_slave()} in \file{gtm_cmd.c}.
  
  \FUNC{start_gtm_slave()}
  
      Starts gtm slave.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{init_all()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{start_all()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{do_start()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{add_gtmSlave()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_stopGtmMaster()}
  
      Builds \file{cmd_t} structure to stop gtm master.
      This is called from \file{stop_gtm_master()} in \file{gtm_cmd.c}.
  
  \FUNC{stop_gtm_master()}
  
      Stops gtm master.
      %
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{stop_all()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{do_stop_command()}{do_command.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_stopGtmSlave()}
  
      Builds \file{cmd_t} structure to stop gtm slave.
      This is called from \file{stop_gtm_slave} in \file{gtm_cmd.c}.
  
  \FUNC{stop_gtm_slave()}
  
      Stops gtm slave.
      This is called from \file{stop_all()} and \file{do_stop_command()} in \file{do_command.c}.
  
  \FUNC{prepare_killGtmMaster()}
  
      Builds \file{cmd_t} structure to kill gtm master.
      This is called from \file{kill_gtm_master} in \file{gtm_cmd.c}.
  
  \FUNC{kill_gtm_master()}
  
      Kills gtm master process.
      This is called from \file{do_kill_command()} in \file{do_command.c}.
  
  \FUNC{prepare_killGtmSlave()}
  
      Builds \file{cmd_t} structure to kill gtm master.
      This is called from \file{kill_gtm_master()} in \file{gtm_cmd.c}.
  
  
  \FUNC{kill_gtm_master()}
  
      Kills gtm master.
      This is called from \file{do_kill_command()} in \file{do_command.c}.
  
  \FUNC{prepare_killGtmSlave()}
  
      Builds \file{cmd_t} structure to kill gtm slave.
      This is called from \file{kill_gtm_slave()} in \file{gtm_cmd.c}.
  
  \FUNC{kill_gtm_slave()}
  
      Kills gtm slave.
      This is called from \file{do_kill_command()} in \file{do_command.c}.
  
  \FUNC{failover_gtm()}
  
      Promotes a gtm slave and run it as the new master.
      This is called from \file{do_failover_command()} in \file{do_command.c}.
  
  \FUNC{prepare_cleanGtmMaster()}
  
      Builds \file{cmd_t} structure to cleanup gtm master resources.
      This is called from \file{clean_gtm_master()} in \file{gtm_cmd.c}.
  
  \FUNC{clean_gtm_master()}
  
      Cleans up gtm master resources.
      This is called from \file{do_clean_command()} in \file{do_command.c}
  
  \FUNC{prepare_cleanGtmSlave()}
  
      Build \file{cmd_t} structure to cleanup gtm slave resources.
      %
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{do_clean_command()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{clean_gtm_slave()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{clean_gtm_slave()}
  
      Cleans up gtm slave resources.
      
      \FuncRefHdr
		  \FuncRef{do_clean_command()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{remove_gtmSlave}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{add_gtmProxy()}
  
      Adds gtm proxy.
      Please note that \file{postgresql.conf} of affected coordinator and datanode will be
	  updated and they will be restarted.
      
      This is called from \file{do_add_command()} in \file{do_command.c}.
  
  \FUNC{remove_gtmProxy()}
  
      Removes gtm proxy.
      Please note that \file{postgresql.conf} of affected coordinator and datanode will be
	  updated and they will be restarted.
      
      This is called from \file{do_remove_command()} in \file{do_command.c}.
  
  \FUNC{prepare_initGtmProxy()}
  
      Builds \file{cmd_t} structure to initialize gtm proxy.
      This is called from \file{init_gtm_proxy()} in \file{gtm_cmd.c}.
  
  \FUNC{init_gtm_proxy()}
  
      Initializes gtm proxy.
      This is called from \file{add_gtmProxy()} and \file{init_gtm_proxy_all()} in \file{gtm_cmd.c}.
  
  \FUNC{init_gtm_proxy_all()}
  
      Initializes all the gtm proxies defined in the configuration file.
      This is called from \file{init_all()} and \file{do_init_command()} in \file{do_command.c}.
  
  \FUNC{prepare_startGtmProxy()}
  
      Builds \file{cmd_t} structure to start gtm proxy.
      This is called form \file{start_gtm_proxy()} in \file{gtm_cmd.c}.
  
  \FUNC{start_gtm_proxy()}
  
      Starts gtm proxy.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{do_start_command()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{rdd_gtmProxy()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{start_gtm_proxy_all()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{start_gtm_proxy_all()}
  
      Starts all the gtm proxies.
      This is called from \file{init_all()}, \file{start_all()} and \file{do_start_command()} in
	  \file{do_command.c}.
  
  \FUNC{prepare_stopGtmProxy()}
  
      Builds \file{cmd_t} structure to stop gtm proxy.
      This is called from \file{stop_gtm_proxy()} in \file{gtm_cmd.c}.
  
  \FUNC{stop_gtm_proxy()}
  
      Stops gtm proxies.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{do_stop_command()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{stop_gtm_proxy_all()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{stop_gtm_proxy_all()}
  
      Stops all the gtm proxies.
      This is called from \file{stop_all()} and \file{do_stop_command()} in \file{do_command.c}.
  
  \FUNC{prepare_killGtmProxy()}
  
      Builds \file{cmd_t} structure to kill a gtm proxy.
      This is called from \file{kill_gtm_proxy()} in \file{gtm_cmd.c}.
  
  \FUNC{kill_gtm_proxy()}
  
      Kills gtm proxies.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{do_kill_command()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{kill_something()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{kill_gtm_proxy_all()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{kill_gtm_proxy_all()}
  
      Kills all the gtm proxies.
      It is for the future use and is not used now.
  
  \FUNC{prepare_reconnectGtmProxy()}
  
      Builds \file{cmd_t} structure to perform \texttt{reconnect} command.
      This is called from \file{reconnect_gtm_proxy()} in \file{gtm_cmd.c}.
  
  \FUNC{reconnect_gtm_proxy()}
  
      Reconnects gtm proxies to new gtm master.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{do_reconnect_command()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{reconnect_gtm_proxy_all()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{prepare_cleanGtmProxy()}
  
      Builds \file{cmd_t} structure to clean up gtm proxy resources.
      This is called from \file{clean_gtm_proxy()} in \file{gtm_cmd.c}.
  
  \FUNC{clean_gtm_proxy()}
  
      Cleans up gtm proxy resources.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{do_clean_command()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{remove_gtmProxy()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{clean_gtm_proxy_all()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{show_config_gtmMaster()}
  
      Shows gtm master configuration.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{show_config_something()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{show_configuration()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{show_config_host()}{do_command.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{show_config_gtmSlave()}
  
      Shows gtm slave configuration.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{show_config_something()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{show_configuration()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{show_config_host()}{do_command.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor
  
  \FUNC{show_config_gtmProxies()}
  
      Shows configuration of gtm proxies..
      This is called from \file{show_configuration()} from \file{do_command.c}.
  
  \FUNC{show_config_gtmProxy()}
  
      Shows configuration of a gtm proxy.
      This is called from the following codes:
      
      \FuncRefHdr
		  \FuncRef{show_config_something()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{show_config_host()}{do_command.c}{
		  }\vspace{-10pt} \\ 
		  \FuncRef{show_config_gtmProxies()}{gtm_cmd.c}{
		  }\vspace{-10pt} \\ \hline
      \FuncRefTrailor



% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{gtm\_util.c}}

  This module handles direct communication with gtm and gtm proxies internally.
  
  Functions defined in this module are as follows:
  
  \FUNC{inputError()}
  
      Internal input error handler.
      This is a utility function and called from various codes inside \file{gtm_util.c}.
  
  \FUNC{unregisterFromGtm()}
  
      Handles \texttt{unregister} command to unregister specified node from GTM.
      This is called from \file{do_singleLine()} in \file{do_command.c}.
  
  \FUNC{connectGTM()}
  
      Establish connection to gtm.
      This is a utility function and called from various codes inside \file{gtm_util.c}.
  
  \FUNC{process_unregister_command()}
  
      Handles unregistration from GTM.
      This code uses gtm module from \file{src/gtm}.
      
      This function is called from \file{unregisterFromGtm()} in \file{gtm_util.c} and also used
      inside macros \file{unregister_gtm_proxy()}, \file{unregister_coordinator()} and
	  \file{unregister_detanode()} defined in \file{gtm_util.h}.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{make\_signature}}

  This is a bash script which creates signature file to build following files:
  
  \begin{itemize}
	  \item Signature file used to check if runtime bash script matches \file{pgxc_ctl} binary.
	  \item Source code which contains runtime bash script to provide default configuration
	  		values and to read predefined configuration variable values.
  \end{itemize}


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{mcxt.c}}

  This is abstract memory handling module.
  Some \XC{} modules depend upon \file{palloc()}, \file{pfree()} and other postmaster-specific
  memory allocation, which should be replaced with bare malloc() and free() in \file{pgxc_ctl}.
  This modules handles such difference.
  
  Implementation is straightforward and the detailed description of functions are not given
  here, except for major function interfaces.
  
  It is for the future use and is not used at present.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{monitor.c}}

  This module monitors if specified component is running.
  Structure of the module is very straightforward and detailed description of all
  the functions will not be given, except for important ones.
  
  Monitoring itself for gtm/gtm proxy and coordinator/datanode are done in different manners.
  
  Monitoring gtm and gtm proxy is implemented in the function \file{do_gtm_ping()}, which
  establishes connection to specified gtm or gtm proxy by using \file{PQconnectGTM()} function
  provided at \file{src/gtm}.
  
  Monitoring coordinator and datanode is done by the function \file{pingNode()} function in \file{utils.c}.
  In this function, \file{PQPing()} is used to check if the target coordinator or datanode is running.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{pgxc\_ctl.bash}}

  This is the original bash script used to write current \file{pgxc_ctl}.
  The script is helpful to learn what steps are taken in \file{pgxc_ctl} and is here
  because of this reason.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{pgxc\_ctl.c}}

  This is the main \file{pgxc_ctl} utility.
  
  This handles bash command option when \file{pgxc_ctl} is invoked, reads configuration file,
  sets up working environment and handles each command line by line.
  
  This section will give general steps how \file{pgxc_ctl} runs.
  
  % pgxc_ctl general steps
  \begin{enumerate}
	  \item \file{main()} handles its own command line options.
	  		If help or version printing is specified, do them and quit.
	  \item  Reads environment file from \file{/etc/pgxc_ctl} and \file{$HOME/.pgxc_ctl} using
			\file{setup_my_env()} in \file{pgxc_ctl.c}.
	  		This function reads environment parameters from these files such as \file{pgxc_ctl} home
			directory, prompt, verbosity, log directory, log file name, and configuration file name
			among others.
	  \item Starts logging with \file{sgtartLog()} in \file{pgxc_ctl.c}.
	  \item \label{pgxcCtl:step:4}Installs \file{bash} script file which contains bash scripts to read
	  		final bash variables defining \XC{} configuration, as well as default value of the configuration.
			\file{prepare_pgxc_ctl_bash()} in \file{pgxc_ctl.c} handles this.
	  		All the scripts will be found in \file{pgxc_ctl_bash.c}.
	  \item Builds a path to the configuration file using \file{build_configuration_path()} in \file{pgxc_ctl.c}.
	  \item Reads configuration variable values using \file{read_configuration()} in \file{pgxc_ctl.c}.
	  		This function invokes the bash script installed in the step~ \ref{pgxcCtl:step:4} with
			options to read the configuration file.
	  		The script will read all the predefined bash script variables to construct \XC{} cluster
			configuration.
	  		This way, DBAs can write any bash shortcuts for their needs to make configuration more
			comprehensible.
	  \item Checks the configuration.
	  		If there's no conflict, then \file{pgxc_ctl} begins to read a command line by line by
			\file{do_command()} in \file{do_command.c}.
  \end{enumerate}
  
  \file{pgxc_ctl} accepts its command as \file{pgxc_ctl} command arguments.
  In this case, only these commands are handled and \file{pgxc_ctl} exists then.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{pgxc\_ctl\_bash.c}}

  This module holds configuration template.
  It is generated by \file{make_signature}.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{pgxc\_ctl\_bash.c}}

  This module contains default configuration values and bash script to read the configuration file.
  It is generated by \file{make_signature}.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{pgxc\_ctl\_bash\_2}}

  This module is \file{bash} script which holds bash functions to read \file{pgxc_ctl} configuration file.
  This is read by \file{make_signature} and included into \file{pgxc_ctl_bash.c}.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{pgxc\_ctl\_conf\_part}}

  This module is \file{bash} script which holds default configuration variables.
  This is read by \file{make_signature} and included into \file{pgxc_ctl_bash.c}.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{pgxc\_ctl\_log.c}}

  This is \file{pgxc_ctl}'s logging module.
  Functions in this modules are simplified version of \file{elog} module in the postmaster and gtm.
  
  Detailed description of this module will not be given here.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{signature.h}}

  This holds signature information generated by \file{make_signature} script used to check if
  internal bash script matches \file{pgxc_ctl} binary.
  It is for the future use and is not used at present.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{utils.c}}

  This module contains miscellaneous utility functions.
  
  Most of them are wrapper function for general library.
  Non-wrapper function description will be given.
  Because they are general utility functions, their caller may no be given unless needed.
  
  \FUNC{appendFiles()}
  
      Appends contents of the specified file path to specified file descriptor.
      It is used to collect more than one optional files.
  
  \FUNC{prepareLocalStdin()}
  
      Collects contents of one or more than one file into a single one as \file{stdin} and returns its
      file descriptor.
  
  \FUNC{makeActualNodeList()}
  
      Checks list of the node, suppress \file{NULL} value (as the string ``\file{none}'' or ``\file{N/A}'')
      and return the list with valid node list.
  
  \FUNC{gtmProxyIdx()}
  
      Finds gtm proxy local to the given component.
  
  \FUNC{coordIdx()}
  
      Finds internal index of the given coordinator.
  
  \FUNC{datanodeIdx()}
  
      Finds internal index of the given datanode.
  
  \FUNC{getEffectiveGtmProxyIdxFromServerName()}
  
      Finds gtm proxy available at given server.
  
  \FUNC{get_prog_pid()}
  
      Finds the process ID of given component.
  
  \FUNC{pingNode()}
  
      Monitors if specified coordinator or datanode is running.
      It uses \file{PQPing()} API of libpq.
  
  \FUNC{getChPidList()}
  
      Gets a list of child processes of given PID at given host.
  
  \FUNC{getIpAddress()}
  
      Finds IP address of the given host.
  
  \FUNC{myUsleep()}
  
      Sleeps in microsecond.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{variables.c}

  \file{pgxc_ctl} depends upon \file{bash} variable values read from the configuration file.
  To make source code more comprehensible and maintain clear relation to the original
  configuration file, most of \file{pgxc_ctl} modules depends upon variable system
  provided by this module.
  
  \file{varnames.h} defines macros to translate C language symbols into real parameter values.
  See below for details.
  
  \file{variables.h} gives some internal structure of the variable system, as well as
  convenient macros.
  
  First of all, \file{pgxc_ctl}'s variable system does not distinguish arrays from scalars.
  Each variable is internally treated as an array.
  
  If application (other code in \file{pgxc_ctl}) need to handle some variable as scalar, it
  just takes first member of the array.
  Shortcut macros are provided to handle this simply.
  
  All the variables are represented as single list, as defined in \file{pgxc_ctl_var} structure
  in \file{variables.h}, as well as the head and tail defined as \file{var_head} and \file{var_tail}
  respectively.
  
  To improve the performance, variables are organized into hash index.
  Hash bucket structure is defined as \file{pgxc_var_hash} structure in \file{variables.h}.
  
  External functions and macros defined in \file{variable.c} and \file{variable.h} are as follows:
  
  \FUNC{init_var_hash()}
  
      Initializes has table.
  
  \FUNC{add_var_hash()}
  
      Adds new variable to the hash.
  
  \FUNC{new_var()}
  
      Adds new variable.
  
  \FUNC{remove_var()}
  
      Removes the variable from the list and hash table, then free it.
  
  \FUNC{add_val()}
  
      Adds a value to the variable as a new array element.
  
  \FUNC{add_val_name()}
  
      Adds a value to the variable with a given name.
  
  \FUNC{find_var()}
  
      Finds variable structure with a given name.
  
  \FUNC{svar()} 
  
      Returns the value of the variable as a scalar.
  
  \FUNC{aval()}
  
      Returns the value of the variable as an array.
  
  \FUNC{reset_value()}
  
      Resets the value of the variable to NULL.
  
  \FUNC{assign_val()}
  
      Copys the source variable values to the destination.
  
  \FUNC{reset_var()}
  
      Similar to \file{reset_value()} but variable is specified by name, not structure address.
  
  \FUNC{reset_var_val()}
  
      Resets specified variable value and assign specified value to it.
  
  \FUNC{confirm_var()}
  
      Finds the address of specified variable.
      If not found, allocate it.
  
  \FUNC{pirnt_vars()}
  
      Prints all the variables.
  
  \FUNC{print_var()}
  
      Prints specified variable.
  
  \FUNC{log_var()}
  
      Prints specified variable to the log.
  
  \FUNC{arraySizeName()}
  
      Returns array size of the variable specified by name.
  
  \FUNC{arraySize()}
  
      Returns array size of the variable specified by address.
  
  \FUNC{add_member()}
  
      Appends the specified array value to specified variable array.
  
  \FUNC{clean_array()}
  
      Frees specified array value.
  
  \FUNC{var_assign()}
  
      Frees the destination and assign the source to the destination.
  
  \FUNC{listValue()}
  
      Returns string representation of the variable value.
  
  \FUNC{ifExists()}
  
      Returns if the variable exists and valid value is assigned to it.
  
  \FUNC{extendVar()}
  
      Extends the size of the array of the variable and add specified value to it.
      Extended array element value is initialized with specified padding string.
  
  \FUNC{assign_arrayEl()}
  
      Assigns a string scalar value to specified element of the array.
      If specified element index is larger than existing value, then
      the size will be extended and additional element is initialized
      with the padding string before the specified element value is set.
  
  \FUNC{doesExist()}
  
      Tests if specified array element of the specified variable name exists.
  
  \FUNC{AddMember(a, b)}
  
      This is a macro defined in \file{variables.h}.
      Appends specified array \file{a} to the variable specified by the name \file{b} and replace
	  the value \file{a}  with the new array.
  
  \FUNC{CleanArray(a)}
  
      Cleans the array \file{a} and assign \file{NULL} to \file{a}.
  
  \FUNC{VAR(a)}
  
      Returns address of the variable with the name \file{a}.


% - - - - subsubsection - - - - - - -  - - - - - - - - - - - - - - - - - - - - -

\subsubsection{\texttt{varnames.h}}

  Defines variable symbol for the name.
  The symbol \texttt{VAR\_}\textit{name} is defined as the variable name ``\textit{name}.''
  
  % {Variable module.} \\
  	%{\tt variables.h} & {{\tt variable.c} interface definition.} \\
  	%{\tt varnames.h} & {Definition of variable symbol and variable name string.} \\
